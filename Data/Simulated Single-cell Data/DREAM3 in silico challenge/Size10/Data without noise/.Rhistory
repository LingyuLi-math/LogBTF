## for train
x <- as.data.frame(datahat)
y <- datahatA[2:n,1]
## for validation
x01 <- as.data.frame(datahatA[1:(n-1),])
sgn <- function(xx){
# xx <- as.matrix(x) %*% coef[-1] + coef[1]
# class(xx)
y <- xx
for (k in 1:dim(xx)[1]) {
# k <- 1
if (xx[k,1] >= 0)
y[k,] <- 1
else (y[k,] <- 0)
}
return(y)
}
coefall <- c()
predall <- c()
AUCall <- c()
ptrainall <- c()
library(glmnet)
library(pROC)
for (j in 1:p) {
# j <- 1
y <- datahatA[2:n,j]
set.seed(123)
glm.fit <- glm(y~., x, family = binomial, control = list(maxit = 100))
# step(glm.fit)
coef <- round(glm.fit$coefficients,3)
## 将NA变成0
# coef[is.na(coef)] <- 0
coefall <- rbind(coefall, coef)
pred <- predict(glm.fit, x, type = "response")
predall <- cbind(predall, pred)
ptrain <- sgn(as.matrix(x01) %*% coef[-1] + coef[1])
ptrainall <- cbind(ptrainall, ptrain)
aucplot <- plot.roc(as.numeric(y), as.numeric(pred), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
print(j)
}
namecol <- c("Intercept", "G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
colnames(coefall) <- namecol
namerow <- c("G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
rownames(coefall) <- namerow
sum(coefall[,2:11]!=0)
View(coefall)
View(coefall)
rm(list = ls())
setwd("D:\\E\\博士\\R_程序\\Boolean\\Data\\DREAM\\DREAM3 in silico challenge\\Size10\\Data without noise")
data = as.matrix(read.table(file = "InSilicoSize10-Ecoli1-nonoise-trajectories.tsv", header=T))
# data = as.matrix(read.table(file = "InSilicoSize10-Yeast1-nonoise-trajectories.tsv", header=T))
p1 <- c(1:21)
p2 <- c(22:42)
p3 <- c(1:21)
p4 <- c(1:21)
datanum <- apply(data[p4,-1],2, as.numeric)
n <- dim(datanum)[1]
p <- dim(datanum)[2]
View(datanum)
rm(list = ls())
setwd("D:\\E\\博士\\R_程序\\Boolean\\Data\\DREAM\\DREAM3 in silico challenge\\Size10\\Data without noise")
data = as.matrix(read.table(file = "InSilicoSize10-Ecoli1-nonoise-trajectories.tsv", header=T))
# data = as.matrix(read.table(file = "InSilicoSize10-Yeast1-nonoise-trajectories.tsv", header=T))
p1 <- c(1:21)
p2 <- c(22:42)
p3 <- c(43:63)
p4 <- c(64:84)
datanum <- apply(data[p4,-1],2, as.numeric)
n <- dim(datanum)[1]
p <- dim(datanum)[2]
View(datanum)
## Kmeans 二值化
library(BiTrinA)
## features*times - A n x m matrix comprising m raw measurements of n features
# binarizeMatrix(t(datanum))
datahatA <- t(binarizeMatrix(t(datanum),method="kMeans")[,1:n])
## noise  对X矩阵中的1做扰动
set.seed(2022)
res <- datahatA[1:(n-1),]
noiseLevel = 1e-5
res <- res + matrix(rnorm(mean=0, sd=noiseLevel, n = length(res)), nrow=nrow(res))
res[1,]
## 将原来为0的变成0
for (i in 1:(dim(res)[1])) {
# i <- 1
for (j in 1:dim(res)[2]) {
# j <- 2
if (datahatA[i,j] == 0)
res[i,j] <- 0
}
}
datahat <- res
colnames(datahat) <- c("G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
## split train and test data
## for train
x <- as.data.frame(datahat)
y <- datahatA[2:n,1]
## for validation
x01 <- as.data.frame(datahatA[1:(n-1),])
sgn <- function(xx){
# xx <- as.matrix(x) %*% coef[-1] + coef[1]
# class(xx)
y <- xx
for (k in 1:dim(xx)[1]) {
# k <- 1
if (xx[k,1] >= 0)
y[k,] <- 1
else (y[k,] <- 0)
}
return(y)
}
coefall <- c()
predall <- c()
AUCall <- c()
ptrainall <- c()
library(glmnet)
library(pROC)
for (j in 1:p) {
# j <- 1
y <- datahatA[2:n,j]
set.seed(123)
glm.fit <- glm(y~., x, family = binomial, control = list(maxit = 100))
# step(glm.fit)
coef <- round(glm.fit$coefficients,3)
## 将NA变成0
# coef[is.na(coef)] <- 0
coefall <- rbind(coefall, coef)
pred <- predict(glm.fit, x, type = "response")
predall <- cbind(predall, pred)
ptrain <- sgn(as.matrix(x01) %*% coef[-1] + coef[1])
ptrainall <- cbind(ptrainall, ptrain)
aucplot <- plot.roc(as.numeric(y), as.numeric(pred), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
print(j)
}
namecol <- c("Intercept", "G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
colnames(coefall) <- namecol
namerow <- c("G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
rownames(coefall) <- namerow
sum(coefall[,2:11]!=0)
View(coefall)
## Dynamics Acc
colnames(ptrainall) <- namerow
X <- datahatA[-1,]
kk <- 0
for (j in 1:dim(X)[2]) {
for (k in 1:(dim(X)[1])) {
if (as.numeric(ptrainall[k,j]) == as.numeric(X[k,j]))
kk <- kk + 1
}
}
kk
err <- kk/((dim(X)[2])*(dim(X)[1]))
err
sum(abs(ptrainall-X))
setwd("D:\\E\\博士\\R_程序\\Boolean\\Data\\DREAM\\DREAM3 in silico challenge\\Size10\\Networks")
gold <- read.table("InSilicoSize10-Ecoli1.tsv",header = F)
# genes <- c(as.character(gold[,1]), as.character(gold[,2]))
# genes <- genes[!duplicated(genes)]
genes <- c("G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
library(igraph)
G <- graph_from_data_frame(gold, directed=T, vertices=genes)
print(G, e=TRUE, v=TRUE)
# plot(G)
adj <- get.adjacency(G,sparse=FALSE)
# View(adj[1:10,1:10])
# write.csv(adj, 'adjmatrix_comp.csv')
## Net1
# adj[2,1] <- adj[2,3]  <- adj[9,4] <- adj[3,5] <- adj[10,7] <- adj[8,7] <- adj[3,7] <- -1
##Net2
# adj[5,3] <- adj[1,4]  <- adj[1,5] <- adj[5,6] <- adj[1,7] <- adj[5,7] <- adj[1,8] <- adj[5,8] <- -1
## Yeast1
adj <- -adj
adj[1,5] <- 1
a <- adj
SIGN <- 1
if(SIGN==1){
a[row(a)==col(a)] <- 0
}
if(SIGN==0){
a[which(a!=0)] <- 1
}
adj_matrix <- t(coefall[,-1])
#Final ranked list, AUROC and AUPR
adj_matrix <- adj_matrix/max(abs(adj_matrix))
library(pracma)
auc_from_ranks_TC_sign <- dget("D:/E/博士/R_程序/Boolean/R/SINCERITIES functions/auc_from_ranks_TC_sign.R")
AUCresult <- auc_from_ranks_TC_sign(adj_matrix,a,20)
AUROC <- AUCresult$AUROC
AUPR <- AUCresult$AUPR
AUC <- cbind(AUROC,AUPR)
View(coefall)
View(datahatA)
rm(list = ls())
# setwd("/home/lly/R/Boolean/Data/DREAM/DREAM3 in silico challenge/Size10/Data without noise")
setwd("D:\\E\\博士\\R_程序\\Boolean\\Data\\DREAM\\DREAM3 in silico challenge\\Size10\\Data without noise")
data = as.matrix(read.table(file = "InSilicoSize10-Ecoli1-nonoise-trajectories.tsv", header=T))
# data = as.matrix(read.table(file = "InSilicoSize10-Yeast1-nonoise-trajectories.tsv", header=T))
p1 <- c(1:21)
p2 <- c(22:42)
p3 <- c(43:63)
p4 <- c(64:84)
datanum <- apply(data[p4,-1],2, as.numeric)
n <- dim(datanum)[1]
p <- dim(datanum)[2]
View(datanum)
## Kmeans ??????
library(BiTrinA)
## features*times - A n x m matrix comprising m raw measurements of n features
# binarizeMatrix(t(datanum))
datahatA <- t(binarizeMatrix(t(datanum),method="kMeans")[,1:n])
## noise  ??X?????е?1??????
set.seed(2022)
res <- datahatA[1:(n-1),]
noiseLevel = 1e-5
res <- res + matrix(rnorm(mean=0, sd=noiseLevel, n = length(res)), nrow=nrow(res))
res[1,]
## when 1, it add noise
for (i in 1:(dim(res)[1])) {
# i <- 1
for (j in 1:dim(res)[2]) {
# j <- 2
if (datahatA[i,j] == 0)
res[i,j] <- 0
}
}
datahat <- res
colnames(datahat) <- c("G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
## split train and test data
## for train
x <- as.data.frame(datahat)
y <- datahatA[2:n,1]
## for validation
x01 <- as.data.frame(datahatA[1:(n-1),])
sgn <- function(xx){
# xx <- as.matrix(x) %*% coef[-1] + coef[1]
# class(xx)
y <- xx
for (k in 1:dim(xx)[1]) {
# k <- 1
if (xx[k,1] >= 0)
y[k,] <- 1
else (y[k,] <- 0)
}
return(y)
}
coefall <- c()
predall <- c()
AUCall <- c()
ptrainall <- c()
library(glmnet)
library(pROC)
for (j in 1:p) {
# j <- 1
y <- datahatA[2:n,j]
set.seed(123)
glm.fit <- glm(y~., x, family = "binomial", control = list(maxit = 100))
# coef <- glm.fit$coefficients
coef <- round(glm.fit$coefficients,4)
# coef[is.na(coef)] <- 0
coefall <- cbind(coefall, coef)
pred <- predict(glm.fit, x, type = "response")
predall <- cbind(predall, pred)
ptrain <- sgn(as.matrix(x01) %*% coef[-1] + coef[1])
ptrainall <- cbind(ptrainall, ptrain)
aucplot <- plot.roc(as.numeric(y), as.numeric(pred), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
print(j)
}
namerow <- c("Intercept", "G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
rownames(coefall) <- namerow
namecol <- c("G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
colnames(coefall) <- namecol
sum(coefall[2:11,]!=0)
DyAcc <- function(datahatA,ptrainall){
X <- datahatA[-1,]
kk <- 0
for (j in 1:dim(X)[2]) {
for (k in 1:(dim(X)[1])) {
if (as.numeric(ptrainall[k,j]) == as.numeric(X[k,j]))
kk <- kk + 1
}
}
acc <- kk/((dim(X)[2])*(dim(X)[1]))
return(acc)
}
acc <- DyAcc(datahatA,ptrainall)
acc
View(coefall)
## 2022.6.2 比较glm(noise)和penalty glm(leave one)的coef
## 2022.7.19 精简code，只保留glm和RegLog
## 2022.7.27 添加基因的数目、边的数目信息
## 2022.7.27 method 1-Ridge; 2-ENet; 3-Lasso
# Glmnet + Glm noise ------------------------------------------------------------------
rm(list = ls())
# options(digits = 7)
##
set.seed(123)
##
method <- 2
## 0-不排除对角线
noDIAG = 1
genenum <- 10
filenum <- 1
source('D:\\E\\博士\\R_程序/Boolean/R/SINCERITIES functions/PermanceFunction.R')
l <- 21
# datapath <- paste("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
datapath <- paste("/home/lly/R/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
filenum <- 4
# datapath <- paste("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
datapath <- paste("/home/lly/R/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
dataauto <- paste(datapath,"InSilicoSize",genenum,"-Ecoli",filenum,"-nonoise-trajectories.tsv",sep="")
datapath <- paste("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
dataauto <- paste(datapath,"InSilicoSize",genenum,"-Ecoli",filenum,"-nonoise-trajectories.tsv",sep="")
Data = as.matrix(read.table(file = dataauto, header=T))
run <- dim(Data)[1]/l
filenum <- 1
dataauto <- paste(datapath,"InSilicoSize",genenum,"-Ecoli",filenum,"-nonoise-trajectories.tsv",sep="")
Data = as.matrix(read.table(file = dataauto, header=T))
run <- dim(Data)[1]/l
AUCALL <- c()
AUCALL0 <- c()
ResultAll <- c()
ResultAll0 <- c()
meanAUCAccAll <- c()
run
k <- 4
datanum <- apply(Data[c(((k-1)*l+1):(k*l)),-1],2, as.numeric)
n <- dim(datanum)[1]
p <- dim(datanum)[2]
## scale
# datascale <- scale(datanum)
# datahatA <- pmax(sign(datascale), 0)
## Kmeans ??????
library(BiTrinA)
## features*times - A n x m matrix comprising m raw measurements of n features
datahatA <- t(binarizeMatrix(t(datanum),method="kMeans")[,1:n])
# write.csv(t(datahatA), "CoefAllSize10\\datadream3p1_matrix.csv")
View(datanum)
## noise  ??X?????е?1??????
set.seed(2022)
res <- datahatA[1:(n-1),]
noiseLevel = 1e-5
res <- res + matrix(rnorm(mean=0, sd=noiseLevel, n = length(res)), nrow=nrow(res))
## when 1, it add noise
for (i in 1:(dim(res)[1])) {
# i <- 1
for (j in 1:dim(res)[2]) {
# j <- 2
if (datahatA[i,j] == 0)
res[i,j] <- 0
}
}
datahat <- res
## split train and test data
## for train
xglm <- as.data.frame(datahat)
yglm <- datahatA[-1,]
## for validation
xglm01 <- as.data.frame(datahatA[1:(n-1),])
## glmnet
data <- datahatA
num_time_points <- dim(data)[1]
numGENES <- dim(data)[2]
#Generate Y and X_matrix for glmnet
if(method==1){
alphas <- 0
}else if(method==2){
alphas <- 0.5
}else if(method==3){
alphas <- 1
}else if(method==4){
alphas <- seq(0,1,0.1)
}else{
input <- readline(' *** Please input manually the alpha values (between 0 and 1) separated by comma: ')
alphas <- as.numeric(unlist(strsplit(input,',')))
}
## no scale
DISTANCE_matrix <- as.matrix(data)
## penalty
X_matrix <- DISTANCE_matrix[1:(num_time_points-1),]
n <- dim(X_matrix)[1]
p <- dim(X_matrix)[2]
#LOOCV settings
nfold <- dim(X_matrix)[1]
foldid <- 1:nfold
keep <- TRUE
pred_lambda_min <- matrix(0, nrow = numGENES+1, ncol = numGENES)
lambda_res <- vector()
alpha_res <- vector()
AUCall0 <- c()
ptrainall0 <- c()
View(datanum)
View(X_matrix)
plot(datahatA)
plot(datahatA, twoDimensional=TRUE)
plot(binarize.kMeans(datanum[,1]), twoDimensional=TRUE)
plot(binarize.kMeans(datanum), twoDimensional=TRUE)
View(datanum)
View(datahatA)
plot(binarize.kMeans(datanum[,2]), twoDimensional=TRUE)
library(glmnet)
library(pROC)
for (gi in 1:numGENES) {
# gi <- 2
AUCall <- c()
ptrainall <- c()
cverrorall <- c()
lambda <-  vector()
cvERROR <-  vector()
beta <- matrix(data=0,nrow = dim(X_matrix)[2],ncol = length(alphas))
theta <- matrix(data=0,nrow = dim(X_matrix)[2]+1,ncol = length(alphas))
# for (test in 1:length(alphas)) {
test <- 1
Y_vector <- DISTANCE_matrix[2:(num_time_points),gi]
# if Y exist one 1/0, use noise 0/1 data.
if(sum(Y_vector) == 0 | sum(Y_vector) == n){
glm.fit <- glm(Y_vector~., xglm, family = "binomial", control = list(maxit = 100))
coef <- glm.fit$coefficients
# # coef <- round(glm.fit$coefficients,4)
coef[is.na(coef)] <- 0
pred_lambda_min[,gi] <- coef
# pred <- predict(glm.fit, xglm, type = "response")
# predall <- cbind(predall, pred)
ptrain <- Y_vector    ## 不进化
ptrainall <- cbind(ptrainall, ptrain)
ptrainall0 <- cbind(ptrainall0, ptrainall)
# ptrain <- sgn(as.matrix(xglm01) %*% coef[-1] + coef[1])
# ptrainall <- cbind(ptrainall, ptrain)
# ptrainall0 <- cbind(ptrainall0, ptrainall)
# aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
# auc <- aucplot$auc
# AUCall <- cbind(AUCall, auc)
# AUCall0 <- cbind(AUCall0, AUCall)
}else if(sum(Y_vector) == 1 | sum(Y_vector) == (n-1)){
glm.fit <- glm(Y_vector~., xglm, family = "binomial", control = list(maxit = 100))
coef <- glm.fit$coefficients
# coef <- round(glm.fit$coefficients,4)
coef[is.na(coef)] <- 0
pred_lambda_min[,gi] <- coef
# pred <- predict(glm.fit, xglm, type = "response")
# predall <- cbind(predall, pred)
ptrain <- sgn(as.matrix(xglm01) %*% coef[-1] + coef[1])
ptrainall <- cbind(ptrainall, ptrain)
ptrainall0 <- cbind(ptrainall0, ptrainall)
aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
AUCall0 <- cbind(AUCall0, AUCall)
}else{
## glnnet with positive coef
# if(noDIAG==1){
#   CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],exclude=gi,nfolds = nfold, foldid = foldid,
#                           keep = keep, lower.limits=0, upper.limits=Inf, grouped = FALSE)
# }else{
#   CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],nfolds = nfold, foldid = foldid,
#                           keep = keep, lower.limits=0, upper.limits=Inf, grouped = FALSE)
# }
## glmnet
if(noDIAG==1){
CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],exclude=gi,
nfolds = nfold, foldid = foldid, keep = keep, grouped = FALSE)
}else{
CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],
nfolds = nfold, foldid = foldid, keep = keep, grouped = FALSE)
}
plot(CV_results)
lambda[test] <- CV_results$lambda.min
cvERROR[test] <- CV_results$cvm[CV_results$lambda==CV_results$lambda.min]
cverrorall <- cbind(cverrorall, cvERROR)
# coef.CV_results <- round(coef(CV_results, s='lambda.min'),3)
coef.CV_results <- coef(CV_results, s='lambda.min')
##
beta[coef.CV_results@i[-1],test] = coef.CV_results@x[-1]
theta[coef.CV_results@i+1,test] = coef.CV_results@x
theta[1,test] <- lambda*theta[1,test]
# theta[1,test] <- theta[1,test]/lambda
ptrain <- sgn(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test])
# ptrain <- sgn(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test])
# ptrain <- as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test]
ptrainall <- cbind(ptrainall, ptrain)
# View(cbind(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test],Y_vector))
aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
minIdx <- max(which(cvERROR==min(cvERROR)))
lambda_res[gi] <- lambda[minIdx]
alpha_res[gi] <- alphas[minIdx]
# pred_lambda_min[,gi] <- beta[,minIdx]
pred_lambda_min[,gi] <- theta[,minIdx]
ptrainall0 <- cbind(ptrainall0, as.matrix(ptrainall[,minIdx]))
AUCall0 <- cbind(AUCall0, AUCall[,minIdx])
}
print(gi)
}
mean(AUCall0)
coefall <- pred_lambda_min
View(coefall)
namerow <- c("Intercept", "G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
rownames(coefall) <- namerow
namecol <- c("G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
colnames(coefall) <- namecol
sum(coefall[2:11,]!=0)
## Dynamics Acc
DyAccuracy <- DyAcc(datahatA,ptrainall0)
DyAccuracy
View(AUCall0)
View(coefall)
