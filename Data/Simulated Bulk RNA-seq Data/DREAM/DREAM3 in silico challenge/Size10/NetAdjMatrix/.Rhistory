#   install.packages("BiocManager")
# BiocManager::install("minet")
# library(minet)
# data(syn.data)
# ## input data -- sample*genes
# mim <- build.mim(as.matrix(syn.data),estimator="spearman")
# net <- aracne(mim)
l <- 21
datapath <- paste("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
datapath <- paste("/home/lly/R/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
dataauto <- paste(datapath,"InSilicoSize",genenum,"-Ecoli",filenum,"-nonoise-trajectories.tsv",sep="")
Data = as.matrix(read.table(file = dataauto, header=T))
run <- dim(Data)[1]/l
datanum <- apply(Data[c(((k-1)*l+1):(k*l)),-1],2, as.numeric)
n <- dim(datanum)[1]
p <- dim(datanum)[2]
## Kmeans ??????
# library(BiTrinA)
# ## features*times - A n x m matrix comprising m raw measurements of n features
# # binarizeMatrix(t(datanum))
# datahatA <- t(binarizeMatrix(t(datanum),method="kMeans")[,1:n])
# # write.csv(t(datahatA), "CoefAllSize10\\datadream3p1_matrix.csv")
## expression matrix : sample * genes
exprMatrix <- datanum
# exprMatrix <- datahatA
# ARACEN -----------------------------------------------------------------
library(minet)
## input data -- sample*genes
set.seed(123)
mim <- build.mim(exprMatrix,estimator="spearman")
weightMatrix <- aracne(mim)
## edge link
library(GENIE3)
linkListNum <- min(getLinkList(weightMatrix, reportMax = 52)[,3])
weightMatrix0 <- weightMatrix
weightMatrix0[weightMatrix0 < linkListNum] = 0
weightMatrix0[weightMatrix0 >= linkListNum] = 1
# Glmnet + Glm noise ------------------------------------------------------------------
rm(list = ls())
# options(digits = 7)
## load function
source('D:/E/博士/R_程序/Boolean/R/SINCERITIES functions/PermanceFunction.R')
# source('/home/lly/R/Boolean/R/SINCERITIES functions/PermanceFunction.R')
##
set.seed(123)
##
file <- c(10,1,4,45)
# file <- c(10,2,3,48)
# file <- c(50,1,12,576)
# file <- c(50,2,6,585)
# file <- c(100,1,29,1708)
# file <- c(100,2,11,1996)
method = 2
genenum <- file[1]
filenum <- file[2]
k <- file[3]
geneselect <- file[4]
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# BiocManager::install("minet")
# library(minet)
# data(syn.data)
# ## input data -- sample*genes
# mim <- build.mim(as.matrix(syn.data),estimator="spearman")
# net <- aracne(mim)
l <- 21
datapath <- paste("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
datapath <- paste("/home/lly/R/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
dataauto <- paste(datapath,"InSilicoSize",genenum,"-Ecoli",filenum,"-nonoise-trajectories.tsv",sep="")
Data = as.matrix(read.table(file = dataauto, header=T))
run <- dim(Data)[1]/l
datanum <- apply(Data[c(((k-1)*l+1):(k*l)),-1],2, as.numeric)
n <- dim(datanum)[1]
p <- dim(datanum)[2]
## Kmeans ??????
# library(BiTrinA)
# ## features*times - A n x m matrix comprising m raw measurements of n features
# # binarizeMatrix(t(datanum))
# datahatA <- t(binarizeMatrix(t(datanum),method="kMeans")[,1:n])
# # write.csv(t(datahatA), "CoefAllSize10\\datadream3p1_matrix.csv")
## expression matrix : sample * genes
exprMatrix <- datanum
# exprMatrix <- datahatA
# ARACEN -----------------------------------------------------------------
library(minet)
## input data -- sample*genes
set.seed(123)
mim <- build.mim(exprMatrix,estimator="spearman")
weightMatrix <- aracne(mim)
rm(list = ls())
## load function
source('D:/E/博士/R_程序/Boolean/R/SINCERITIES functions/PermanceFunction.R')
##
set.seed(123)
##
file <- c(10,1,4,45)
method = 2
genenum <- file[1]
filenum <- file[2]
k <- file[3]
geneselect <- file[4]
l <- 21
datapath <- paste("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
# datapath <- paste("/home/lly/R/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
dataauto <- paste(datapath,"InSilicoSize",genenum,"-Ecoli",filenum,"-nonoise-trajectories.tsv",sep="")
Data = as.matrix(read.table(file = dataauto, header=T))
datanum <- apply(Data[c(((k-1)*l+1):(k*l)),-1],2, as.numeric)
run <- dim(Data)[1]/l
n <- dim(datanum)[1]
p <- dim(datanum)[2]
## expression matrix : sample * genes
exprMatrix <- datanum
# ARACEN -----------------------------------------------------------------
library(minet)
## input data -- sample*genes
set.seed(123)
mim <- build.mim(exprMatrix,estimator="spearman")
weightMatrix <- aracne(mim)
View(weightMatrix)
library(minet)
data(syn.data)
View(syn.data)
## input data -- sample*genes
mim <- build.mim(as.matrix(syn.data),estimator="spearman")
net <- aracne(mim)
View(net)
rm(list = ls())
source('D:/E/博士/R_程序/Boolean/R/SINCERITIES functions/PermanceFunction.R')
rm(list = ls())
##
set.seed(123)
file <- c(10,1,4,45)
method = 2
genenum <- file[1]
filenum <- file[2]
k <- file[3]
geneselect <- file[4]
l <- 21
# datapath <- paste("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
datapath <- paste("/home/lly/R/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
datapath <- paste("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
dataauto <- paste(datapath,"InSilicoSize",genenum,"-Ecoli",filenum,"-nonoise-trajectories.tsv",sep="")
Data = as.matrix(read.table(file = dataauto, header=T))
run <- dim(Data)[1]/l
datanum <- apply(Data[c(((k-1)*l+1):(k*l)),-1],2, as.numeric)
n <- dim(datanum)[1]
p <- dim(datanum)[2]
# TREGRESS --  sample*gene
X <- t(datanum)
View(X)
# TIGRESS parameters
nstepsLARS <- 1  # 10 不可行！！！
nsplit <- 1000
library(tigress)
## Train TIGRESS on all TF
set.seed(123)
predTigress <- tigress(t(X), nstepsLARS=nstepsLARS, nsplit=nsplit)
View(X)
## clear
rm(list = ls())
rm(list = ls())
source('D:/E/博士/R_程序/Boolean/R/SINCERITIES functions/PermanceFunction.R')
##
set.seed(123)
##
file <- c(10,1,4,45)
method = 2
genenum <- file[1]
filenum <- file[2]
k <- file[3]
geneselect <- file[4]
l <- 21
datapath <- paste("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size",genenum,"/Data without noise/",sep="")
dataauto <- paste(datapath,"InSilicoSize",genenum,"-Ecoli",filenum,"-nonoise-trajectories.tsv",sep="")
Data = as.matrix(read.table(file = dataauto, header=T))
run <- dim(Data)[1]/l
datanum <- apply(Data[c(((k-1)*l+1):(k*l)),-1],2, as.numeric)
n <- dim(datanum)[1]
p <- dim(datanum)[2]
# TREGRESS --  sample*gene
X <- t(datanum)
# TIGRESS parameters
nstepsLARS <- 1  # 10 不可行！！！
nsplit <- 1000
library(tigress)
## Train TIGRESS on all TF
set.seed(123)
predTigress <- tigress(t(X), nstepsLARS=nstepsLARS, nsplit=nsplit)
# Perf on all TF
weightMatrix <- predTigress[[1]]
View(weightMatrix)
## edge link
library(GENIE3)
getLinkList(weightMatrix, reportMax = 52)
getLinkList(weightMatrix, reportMax = geneselect)
linkListNum <- min(getLinkList(weightMatrix, reportMax = geneselect)[,3])
weightMatrix0 <- weightMatrix
weightMatrix0[weightMatrix0 < linkListNum] = 0
weightMatrix0[weightMatrix0 >= linkListNum] = 1
## 0-无向
SIGN = 0
datapath0 <- paste("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size", genenum, "/NetAdjMatrix/", sep="")
adj_gold0 <- paste(datapath0," InSilicoSize",genenum,"-Ecoli",filenum,"-adj .csv",sep="")
adj_gold <- as.matrix(read.csv(file = adj_gold0))
# no self-loof, direct
if(SIGN == 1){
adj_gold[row(adj_gold) == col(adj_gold)] <- 0
adj_matrix <- weightMatrix0
}
# undirect
if(SIGN == 0){
adj_gold[which(adj_gold != 0)] <- 1
adj_matrix <- abs(weightMatrix0)
}
library(pracma)
library(Matrix)
AUCresult <- auc_from_ranks_TC_sign(adj_matrix, adj_gold, 1000)
AUROC <- AUCresult$AUROC
AUPR <- AUCresult$AUPR
AUC <- cbind(AUROC,AUPR)
AUC
meanAUCAcc <- cbind(geneselect, AUC)
colnames(meanAUCAcc) <- c("link", "AUROC", "AUPR")
performance <- performance_from_ranks_TC_sign(adj_matrix, adj_gold, 0)
Acc0 <- performance$Acc
Recall0 <- performance$Recall
Pre0 <- performance$Pre
FPR0 <- performance$FPR
Fmeasure0 <- performance$Fmeasure
Result0 <- cbind(Acc0,Recall0,Pre0,FPR0,Fmeasure0)
colnames(Result0) <- c("Acc0","Recall0","Pre0","FPR0","Fmeasure0")
## output
output <- cbind(meanAUCAcc, Result0)
output
getLinkList(weightMatrix, reportMax = geneselect)[,3]
min(getLinkList(weightMatrix, reportMax = geneselect)[,3])
library(GENIE3)
linkListNum <- min(getLinkList(weightMatrix, reportMax = geneselect)[,3])
weightMatrix0 <- weightMatrix
weightMatrix0[weightMatrix0 < linkListNum] = 0
weightMatrix0[weightMatrix0 >= linkListNum] = 1
View(weightMatrix0[,1:10])
rm(list = ls())
# options(digits = 7)
## load function
source('D:/E/博士/R_程序/Boolean/R/SINCERITIES functions/PermanceFunction.R')
set.seed(123)
##
method <- 2
## 0-不排除对角线
noDIAG = 1
setwd("D:\\E\\博士\\R_程序\\Boolean/Data/DREAM/DREAM3 in silico challenge/Size10/Data without noise")
# setwd("/home/lly/R/Boolean/Data/DREAM/DREAM3 in silico challenge/Size10/Data without noise")
data = as.matrix(read.table(file = "InSilicoSize10-Ecoli1-nonoise-trajectories.tsv", header=T))
# data = as.matrix(read.table(file = "InSilicoSize10-Yeast3-nonoise-trajectories.tsv", header=T))
l <- 21
p1 <- c(1:l)
p2 <- c(22:(2*l))
p3 <- c(43:(3*l))
p4 <- c(64:(4*l))
datanum <- apply(data[p4,-1],2, as.numeric)
n <- dim(datanum)[1]
p <- dim(datanum)[2]
## Kmeans ??????
library(BiTrinA)
## features*times - A n x m matrix comprising m raw measurements of n features
# binarizeMatrix(t(datanum))
datahatA <- t(binarizeMatrix(t(datanum),method="kMeans")[,1:n])
## noise  ??X?????е?1??????
set.seed(2022)
res <- datahatA[1:(n-1),]
noiseLevel = 1e-5
res <- res + matrix(rnorm(mean=0, sd=noiseLevel, n = length(res)), nrow=nrow(res))
res[1,]
## when 1, it add noise
for (i in 1:(dim(res)[1])) {
# i <- 1
for (j in 1:dim(res)[2]) {
# j <- 2
if (datahatA[i,j] == 0)
res[i,j] <- 0
}
}
datahat <- res
## split train and test data
## for train
xglm <- as.data.frame(datahat)
yglm <- datahatA[-1,]
## for validation
xglm01 <- as.data.frame(datahatA[1:(n-1),])
## glmnet
data <- datahatA
num_time_points <- dim(data)[1]
numGENES <- dim(data)[2]
#Generate Y and X_matrix for glmnet
if(method==1){
alphas <- 0
}else if(method==2){
alphas <- 0.5
}else if(method==3){
alphas <- 1
}else if(method==4){
alphas <- seq(0,1,0.1)
}else{
input <- readline(' *** Please input manually the alpha values (between 0 and 1) separated by comma: ')
alphas <- as.numeric(unlist(strsplit(input,',')))
}
## no scale
DISTANCE_matrix <- as.matrix(data)
## penalty
X_matrix <- DISTANCE_matrix[1:(num_time_points-1),]
n <- dim(X_matrix)[1]
p <- dim(X_matrix)[2]
#LOOCV settings
nfold <- dim(X_matrix)[1]
foldid <- 1:nfold
keep <- TRUE
pred_lambda_min <- matrix(0, nrow = numGENES+1, ncol = numGENES)
lambda_res <- vector()
alpha_res <- vector()
AUCall0 <- c()
ptrainall0 <- c()
# options(digits = 3)
library(glmnet)
library(pROC)
for (gi in 1:numGENES) {
# gi <- 3
AUCall <- c()
ptrainall <- c()
cverrorall <- c()
lambda <-  vector()
cvERROR <-  vector()
beta <- matrix(data=0,nrow = dim(X_matrix)[2],ncol = length(alphas))
theta <- matrix(data=0,nrow = dim(X_matrix)[2]+1,ncol = length(alphas))
# for (test in 1:length(alphas)) {
test <- 1
Y_vector <- DISTANCE_matrix[2:(num_time_points),gi]
# if Y exist one 1/0, use noise 0/1 data.
if(sum(Y_vector) == 1 | sum(Y_vector) == (n-1)){
glm.fit <- glm(Y_vector~., xglm, family = "binomial", control = list(maxit = 100))
coef <- glm.fit$coefficients
# coef <- round(glm.fit$coefficients,4)
# coef[is.na(coef)] <- 0
pred_lambda_min[,gi] <- coef
# pred <- predict(glm.fit, xglm, type = "response")
# predall <- cbind(predall, pred)
ptrain <- sgn(as.matrix(xglm01) %*% coef[-1] + coef[1])
ptrainall <- cbind(ptrainall, ptrain)
ptrainall0 <- cbind(ptrainall0, ptrainall)
aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
AUCall0 <- cbind(AUCall0, AUCall)
}else{
## glnnet with positive coef
# if(noDIAG==1){
#   CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],exclude=gi,nfolds = nfold, foldid = foldid,
#                           keep = keep, lower.limits=0, upper.limits=Inf, grouped = FALSE)
# }else{
#   CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],nfolds = nfold, foldid = foldid,
#                           keep = keep, lower.limits=0, upper.limits=Inf, grouped = FALSE)
# }
## glmnet
if(noDIAG==1){
CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],exclude=gi,
nfolds = nfold, foldid = foldid, keep = keep, grouped = FALSE)
}else{
CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],
nfolds = nfold, foldid = foldid, keep = keep, grouped = FALSE)
}
plot(CV_results)
lambda[test] <- CV_results$lambda.min
cvERROR[test] <- CV_results$cvm[CV_results$lambda==CV_results$lambda.min]
cverrorall <- cbind(cverrorall, cvERROR)
# coef.CV_results <- round(coef(CV_results, s='lambda.min'),3)
coef.CV_results <- coef(CV_results, s='lambda.min')
##
beta[coef.CV_results@i[-1],test] = coef.CV_results@x[-1]
theta[coef.CV_results@i+1,test] = coef.CV_results@x
theta[1,test] <- lambda*theta[1,test]
# theta[1,test] <- theta[1,test]/lambda
ptrain <- sgn(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test])
# ptrain <- sgn(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test])
# ptrain <- as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test]
ptrainall <- cbind(ptrainall, ptrain)
# View(cbind(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test],Y_vector))
aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
minIdx <- max(which(cvERROR==min(cvERROR)))
lambda_res[gi] <- lambda[minIdx]
alpha_res[gi] <- alphas[minIdx]
# pred_lambda_min[,gi] <- beta[,minIdx]
pred_lambda_min[,gi] <- theta[,minIdx]
ptrainall0 <- cbind(ptrainall0, as.matrix(ptrainall[,minIdx]))
AUCall0 <- cbind(AUCall0, AUCall[,minIdx])
}
print(gi)
}
mean(AUCall0)
coefall <- pred_lambda_min
View(coefall)
coefall <- pred_lambda_min
## Dynamics Acc
DyAcc <- DyAcc(datahatA,ptrainall0)
DyAcc
## 0-无向
SIGN = 0
## Gold standard GRN
getwd()
setwd("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size10/NetAdjMatrix")
adj_gold <- as.matrix(read.csv(file = " InSilicoSize10-Ecoli1-adj .csv"))
# no self-loof, direct
if(SIGN == 1){
adj_gold[row(adj_gold) == col(adj_gold)] <- 0
adj_matrix <- coefall[-1,]
}
# undirect
if(SIGN == 0){
adj_gold[which(adj_gold != 0)] <- 1
adj_matrix <- abs(coefall[-1,])
}
adjstand <- apply(abs(adj_matrix), 2, function(x){(x-min(x))/(max(x)-min(x))} )
adjstand[adjstand <= 1e-5] = 0
adj_matrix <- adjstand * sign(adj_matrix)
library(pracma)
AUCresult <- auc_from_ranks_TC_sign(adj_matrix, adj_gold, 1000)
AUROC <- AUCresult$AUROC
AUPR <- AUCresult$AUPR
AUC <- cbind(AUROC,AUPR)
AUC
DyAcc
mean(AUCall0)
performance <- performance_from_ranks_TC_sign(adj_matrix, adj_gold, 0)
performance
# # AUROC and AUPR ----------------------------------------------------------
# # AUROC and AUPR ----------------------------------------------------------
#
# # AUROC and AUPR ----------------------------------------------------------
#
# ## 0-无向
# # AUROC and AUPR ----------------------------------------------------------
#
# ## 0-无向
# SIGN = 0
# # AUROC and AUPR ----------------------------------------------------------
#
# ## 0-无向
# SIGN = 0
# # SIGN = 1
# # AUROC and AUPR ----------------------------------------------------------
#
# ## 0-无向
# SIGN = 0
# # SIGN = 1
#
# # AUROC and AUPR ----------------------------------------------------------
#
# ## 0-无向
# SIGN = 0
# # SIGN = 1
#
# ## Gold standard GRN
# # AUROC and AUPR ----------------------------------------------------------
#
# ## 0-无向
# SIGN = 0
# # SIGN = 1
#
# ## Gold standard GRN
# setwd("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size10/NetAdjMatrix")
# # AUROC and AUPR ----------------------------------------------------------
#
# ## 0-无向
# SIGN = 0
# # SIGN = 1
#
# ## Gold standard GRN
# setwd("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size10/NetAdjMatrix")
# adj_gold <- as.matrix(read.csv(file = " InSilicoSize10-Ecoli1-adj .csv"))
## no zero coefficients and links
numgene <- c()
for (k in 1:p) {
# i <- 9
numgene <- cbind(numgene, as.numeric(summary(adj_matrix[,k] != 0)[3]))
}
numgene
sum(numgene)
max(numgene)
## 0-无向
# SIGN = 0
SIGN = 1
datapath1 <- paste("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size", genenum, "/NetAdjMatrix/", sep="")
adj_gold1 <- paste(datapath1," InSilicoSize",genenum,"-Ecoli",filenum,"-adj .csv",sep="")
adj_gold <- as.matrix(read.csv(file = adj_gold1))
# no self-loof, direct
if(SIGN == 1){
adj_gold[row(adj_gold) == col(adj_gold)] <- 0
adj_matrix <- coefall[-1,]
}
# undirect
if(SIGN == 0){
adj_gold[which(adj_gold != 0)] <- 1
adj_matrix <- abs(coefall[-1,])
}
## Final ranked list, AUROC and AUPR
adjstand <- apply(abs(adj_matrix), 2, function(x){(x-min(x))/(max(x)-min(x))} )
adjstand[adjstand <= 1e-5] = 0
adj_matrix <- adjstand * sign(adj_matrix)
## 把NAN变成0
adj_matrix[is.na(adj_matrix)] <- 0
View(adj_matrix)
