input <- readline(' *** Please input manually the alpha values (between 0 and 1) separated by comma: ')
alphas <- as.numeric(unlist(strsplit(input,',')))
}
## no scale
DISTANCE_matrix <- as.matrix(data)
## penalty
X_matrix <- DISTANCE_matrix[1:(num_time_points-1),]
n <- dim(X_matrix)[1]
p <- dim(X_matrix)[2]
View(X_matrix)
#LOOCV settings
nfold <- dim(X_matrix)[1]
foldid <- 1:nfold
keep <- TRUE
pred_lambda_min <- matrix(0, nrow = numGENES+1, ncol = numGENES)
lambda_res <- vector()
alpha_res <- vector()
AUCall0 <- c()
ptrainall0 <- c()
# options(digits = 3)
library(glmnet)
library(pROC)
for (gi in 1:numGENES) {
# gi <- 19
AUCall <- c()
ptrainall <- c()
cverrorall <- c()
lambda <-  vector()
cvERROR <-  vector()
beta <- matrix(data=0,nrow = dim(X_matrix)[2],ncol = length(alphas))
theta <- matrix(data=0,nrow = dim(X_matrix)[2]+1,ncol = length(alphas))
# for (test in 1:length(alphas)) {
test <- 1
Y_vector <- DISTANCE_matrix[2:(num_time_points),gi]
# if Y exist one 1/0, use noise 0/1 data.
if(sum(Y_vector) == 0 | sum(Y_vector) == n){
glm.fit <- glm(Y_vector~., xglm, family = "binomial", control = list(maxit = 100))
coef <- glm.fit$coefficients
# # coef <- round(glm.fit$coefficients,4)
coef[is.na(coef)] <- 0
pred_lambda_min[,gi] <- coef
# pred <- predict(glm.fit, xglm, type = "response")
# predall <- cbind(predall, pred)
ptrain <- Y_vector    ## 不进化
ptrainall <- cbind(ptrainall, ptrain)
ptrainall0 <- cbind(ptrainall0, ptrainall)
# ptrain <- sgn(as.matrix(xglm01) %*% coef[-1] + coef[1])
# ptrainall <- cbind(ptrainall, ptrain)
# ptrainall0 <- cbind(ptrainall0, ptrainall)
# aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
# auc <- aucplot$auc
# AUCall <- cbind(AUCall, auc)
# AUCall0 <- cbind(AUCall0, AUCall)
}else if(sum(Y_vector) == 1 | sum(Y_vector) == (n-1)){
glm.fit <- glm(Y_vector~., xglm, family = "binomial", control = list(maxit = 100))
coef <- glm.fit$coefficients
# coef <- round(glm.fit$coefficients,4)
# coef[is.na(coef)] <- 0
pred_lambda_min[,gi] <- coef
# pred <- predict(glm.fit, xglm, type = "response")
# predall <- cbind(predall, pred)
ptrain <- sgn(as.matrix(xglm01) %*% coef[-1] + coef[1])
ptrainall <- cbind(ptrainall, ptrain)
ptrainall0 <- cbind(ptrainall0, ptrainall)
aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
AUCall0 <- cbind(AUCall0, AUCall)
}else{
## glnnet with positive coef
# if(noDIAG==1){
#   CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],exclude=gi,nfolds = nfold, foldid = foldid,
#                           keep = keep, lower.limits=0, upper.limits=Inf, grouped = FALSE)
# }else{
#   CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],nfolds = nfold, foldid = foldid,
#                           keep = keep, lower.limits=0, upper.limits=Inf, grouped = FALSE)
# }
## glmnet
if(noDIAG==1){
CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],exclude=gi,
nfolds = nfold, foldid = foldid, keep = keep, grouped = FALSE)
}else{
CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],
nfolds = nfold, foldid = foldid, keep = keep, grouped = FALSE)
}
plot(CV_results)
lambda[test] <- CV_results$lambda.min
cvERROR[test] <- CV_results$cvm[CV_results$lambda==CV_results$lambda.min]
cverrorall <- cbind(cverrorall, cvERROR)
# coef.CV_results <- round(coef(CV_results, s='lambda.min'),3)
coef.CV_results <- coef(CV_results, s='lambda.min')
##
beta[coef.CV_results@i[-1],test] = coef.CV_results@x[-1]
theta[coef.CV_results@i+1,test] = coef.CV_results@x
theta[1,test] <- lambda*theta[1,test]
# theta[1,test] <- theta[1,test]/lambda
ptrain <- sgn(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test])
# ptrain <- sgn(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test])
# ptrain <- as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test]
ptrainall <- cbind(ptrainall, ptrain)
# View(cbind(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test],Y_vector))
aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
minIdx <- max(which(cvERROR==min(cvERROR)))
lambda_res[gi] <- lambda[minIdx]
alpha_res[gi] <- alphas[minIdx]
# pred_lambda_min[,gi] <- beta[,minIdx]
pred_lambda_min[,gi] <- theta[,minIdx]
ptrainall0 <- cbind(ptrainall0, as.matrix(ptrainall[,minIdx]))
AUCall0 <- cbind(AUCall0, AUCall[,minIdx])
}
print(gi)
}
gi <- 2
AUCall <- c()
ptrainall <- c()
cverrorall <- c()
lambda <-  vector()
cvERROR <-  vector()
beta <- matrix(data=0,nrow = dim(X_matrix)[2],ncol = length(alphas))
theta <- matrix(data=0,nrow = dim(X_matrix)[2]+1,ncol = length(alphas))
# for (test in 1:length(alphas)) {
test <- 1
Y_vector <- DISTANCE_matrix[2:(num_time_points),gi]
Y_vector
sum(Y_vector)
glm.fit <- glm(Y_vector~., xglm, family = "binomial", control = list(maxit = 100))
coef <- glm.fit$coefficients
# coef <- round(glm.fit$coefficients,4)
# coef[is.na(coef)] <- 0
pred_lambda_min[,gi] <- coef
coef
# coef <- round(glm.fit$coefficients,4)
coef[is.na(coef)] <- 0
pred_lambda_min[,gi] <- coef
coef
for (gi in 1:numGENES) {
# gi <- 2
AUCall <- c()
ptrainall <- c()
cverrorall <- c()
lambda <-  vector()
cvERROR <-  vector()
beta <- matrix(data=0,nrow = dim(X_matrix)[2],ncol = length(alphas))
theta <- matrix(data=0,nrow = dim(X_matrix)[2]+1,ncol = length(alphas))
# for (test in 1:length(alphas)) {
test <- 1
Y_vector <- DISTANCE_matrix[2:(num_time_points),gi]
# if Y exist one 1/0, use noise 0/1 data.
if(sum(Y_vector) == 0 | sum(Y_vector) == n){
glm.fit <- glm(Y_vector~., xglm, family = "binomial", control = list(maxit = 100))
coef <- glm.fit$coefficients
# # coef <- round(glm.fit$coefficients,4)
coef[is.na(coef)] <- 0
pred_lambda_min[,gi] <- coef
# pred <- predict(glm.fit, xglm, type = "response")
# predall <- cbind(predall, pred)
ptrain <- Y_vector    ## 不进化
ptrainall <- cbind(ptrainall, ptrain)
ptrainall0 <- cbind(ptrainall0, ptrainall)
# ptrain <- sgn(as.matrix(xglm01) %*% coef[-1] + coef[1])
# ptrainall <- cbind(ptrainall, ptrain)
# ptrainall0 <- cbind(ptrainall0, ptrainall)
# aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
# auc <- aucplot$auc
# AUCall <- cbind(AUCall, auc)
# AUCall0 <- cbind(AUCall0, AUCall)
}else if(sum(Y_vector) == 1 | sum(Y_vector) == (n-1)){
glm.fit <- glm(Y_vector~., xglm, family = "binomial", control = list(maxit = 100))
coef <- glm.fit$coefficients
# coef <- round(glm.fit$coefficients,4)
coef[is.na(coef)] <- 0
pred_lambda_min[,gi] <- coef
# pred <- predict(glm.fit, xglm, type = "response")
# predall <- cbind(predall, pred)
ptrain <- sgn(as.matrix(xglm01) %*% coef[-1] + coef[1])
ptrainall <- cbind(ptrainall, ptrain)
ptrainall0 <- cbind(ptrainall0, ptrainall)
aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
AUCall0 <- cbind(AUCall0, AUCall)
}else{
## glnnet with positive coef
# if(noDIAG==1){
#   CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],exclude=gi,nfolds = nfold, foldid = foldid,
#                           keep = keep, lower.limits=0, upper.limits=Inf, grouped = FALSE)
# }else{
#   CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],nfolds = nfold, foldid = foldid,
#                           keep = keep, lower.limits=0, upper.limits=Inf, grouped = FALSE)
# }
## glmnet
if(noDIAG==1){
CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],exclude=gi,
nfolds = nfold, foldid = foldid, keep = keep, grouped = FALSE)
}else{
CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],
nfolds = nfold, foldid = foldid, keep = keep, grouped = FALSE)
}
plot(CV_results)
lambda[test] <- CV_results$lambda.min
cvERROR[test] <- CV_results$cvm[CV_results$lambda==CV_results$lambda.min]
cverrorall <- cbind(cverrorall, cvERROR)
# coef.CV_results <- round(coef(CV_results, s='lambda.min'),3)
coef.CV_results <- coef(CV_results, s='lambda.min')
##
beta[coef.CV_results@i[-1],test] = coef.CV_results@x[-1]
theta[coef.CV_results@i+1,test] = coef.CV_results@x
theta[1,test] <- lambda*theta[1,test]
# theta[1,test] <- theta[1,test]/lambda
ptrain <- sgn(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test])
# ptrain <- sgn(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test])
# ptrain <- as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test]
ptrainall <- cbind(ptrainall, ptrain)
# View(cbind(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test],Y_vector))
aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
minIdx <- max(which(cvERROR==min(cvERROR)))
lambda_res[gi] <- lambda[minIdx]
alpha_res[gi] <- alphas[minIdx]
# pred_lambda_min[,gi] <- beta[,minIdx]
pred_lambda_min[,gi] <- theta[,minIdx]
ptrainall0 <- cbind(ptrainall0, as.matrix(ptrainall[,minIdx]))
AUCall0 <- cbind(AUCall0, AUCall[,minIdx])
}
print(gi)
}
##
AUCALL <- c()
str_c("p", seq(1,7,1))
library(stringr)
str_c("p", seq(1,7,1))
k <- 1
p[k]
p <- str_c("p", seq(1,7,1))
p[k]
# data = as.matrix(read.table(file = "InSilicoSize10-Yeast3-nonoise-trajectories.tsv", header=T))
l <- 21
p1 <- c(1:l)
p2 <- c((l+1):(2*l))
p3 <- c((2*l+1):(3*l))
p4 <- c((3*l+1):(4*l))
p5 <- c((4*l+1):(5*l))
p6 <- c((5*l+1):(6*l))
p7 <- c((6*l+1):(7*l))
library(stringr)
p <- str_c("p", seq(1,7,1))
p[k]
c(p1,p2,p3,p4,p5,p6,p7)
p[1]
c(((k-1)*l+1):(k*l))
##
AUCALL <- c()
for (k in 1:7) {
# k <- 1
datanum <- apply(data[c(((k-1)*l+1):(k*l)),-1],2, as.numeric)
n <- dim(datanum)[1]
p <- dim(datanum)[2]
## scale
# datascale <- scale(datanum)
# datahatA <- pmax(sign(datascale), 0)
## Kmeans ??????
library(BiTrinA)
## features*times - A n x m matrix comprising m raw measurements of n features
# binarizeMatrix(t(datanum))
datahatA <- t(binarizeMatrix(t(datanum),method="kMeans")[,1:n])
# write.csv(t(datahatA), "CoefAllSize10\\datadream3p1_matrix.csv")
## noise  ??X?????е?1??????
set.seed(2022)
res <- datahatA[1:(n-1),]
noiseLevel = 1e-5
res <- res + matrix(rnorm(mean=0, sd=noiseLevel, n = length(res)), nrow=nrow(res))
res[1,]
## when 1, it add noise
for (i in 1:(dim(res)[1])) {
# i <- 1
for (j in 1:dim(res)[2]) {
# j <- 2
if (datahatA[i,j] == 0)
res[i,j] <- 0
}
}
datahat <- res
# colnames(datahat) <- c("G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
sgn <- function(xx){
# xx <- as.matrix(x) %*% coef[-1] + coef[1]
# class(xx)
y <- xx
for (k in 1:dim(xx)[1]) {
# k <- 1
if (xx[k,1] >= 0)
y[k,] <- 1
else (y[k,] <- 0)
}
return(y)
}
## split train and test data
## for train
xglm <- as.data.frame(datahat)
yglm <- datahatA[-1,]
## for validation
xglm01 <- as.data.frame(datahatA[1:(n-1),])
## glmnet
data <- datahatA
num_time_points <- dim(data)[1]
numGENES <- dim(data)[2]
#Generate Y and X_matrix for glmnet
if(method==1){
alphas <- 0
}else if(method==2){
alphas <- 0.5
}else if(method==3){
alphas <- 1
}else if(method==4){
alphas <- seq(0,1,0.1)
}else{
input <- readline(' *** Please input manually the alpha values (between 0 and 1) separated by comma: ')
alphas <- as.numeric(unlist(strsplit(input,',')))
}
## no scale
DISTANCE_matrix <- as.matrix(data)
## with scale
# DISTANCE_matrix <- scale(as.matrix(data))
## penalty
X_matrix <- DISTANCE_matrix[1:(num_time_points-1),]
n <- dim(X_matrix)[1]
p <- dim(X_matrix)[2]
# datascale <- scale(DISTANCE_matrix)
# datascale <- DISTANCE_matrix
# DISTANCE_matrix01 <- pmax(sign(datascale), 0)
# X_matrix01 <- DISTANCE_matrix01[1:(num_time_points-1),]
#LOOCV settings
nfold <- dim(X_matrix)[1]
foldid <- 1:nfold
keep <- TRUE
pred_lambda_min <- matrix(0, nrow = numGENES+1, ncol = numGENES)
lambda_res <- vector()
alpha_res <- vector()
AUCall0 <- c()
ptrainall0 <- c()
# options(digits = 3)
library(glmnet)
library(pROC)
for (gi in 1:numGENES) {
# gi <- 2
AUCall <- c()
ptrainall <- c()
cverrorall <- c()
lambda <-  vector()
cvERROR <-  vector()
beta <- matrix(data=0,nrow = dim(X_matrix)[2],ncol = length(alphas))
theta <- matrix(data=0,nrow = dim(X_matrix)[2]+1,ncol = length(alphas))
# for (test in 1:length(alphas)) {
test <- 1
Y_vector <- DISTANCE_matrix[2:(num_time_points),gi]
# if Y exist one 1/0, use noise 0/1 data.
if(sum(Y_vector) == 0 | sum(Y_vector) == n){
glm.fit <- glm(Y_vector~., xglm, family = "binomial", control = list(maxit = 100))
coef <- glm.fit$coefficients
# # coef <- round(glm.fit$coefficients,4)
coef[is.na(coef)] <- 0
pred_lambda_min[,gi] <- coef
# pred <- predict(glm.fit, xglm, type = "response")
# predall <- cbind(predall, pred)
ptrain <- Y_vector    ## 不进化
ptrainall <- cbind(ptrainall, ptrain)
ptrainall0 <- cbind(ptrainall0, ptrainall)
# ptrain <- sgn(as.matrix(xglm01) %*% coef[-1] + coef[1])
# ptrainall <- cbind(ptrainall, ptrain)
# ptrainall0 <- cbind(ptrainall0, ptrainall)
# aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
# auc <- aucplot$auc
# AUCall <- cbind(AUCall, auc)
# AUCall0 <- cbind(AUCall0, AUCall)
}else if(sum(Y_vector) == 1 | sum(Y_vector) == (n-1)){
glm.fit <- glm(Y_vector~., xglm, family = "binomial", control = list(maxit = 100))
coef <- glm.fit$coefficients
# coef <- round(glm.fit$coefficients,4)
coef[is.na(coef)] <- 0
pred_lambda_min[,gi] <- coef
# pred <- predict(glm.fit, xglm, type = "response")
# predall <- cbind(predall, pred)
ptrain <- sgn(as.matrix(xglm01) %*% coef[-1] + coef[1])
ptrainall <- cbind(ptrainall, ptrain)
ptrainall0 <- cbind(ptrainall0, ptrainall)
aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
AUCall0 <- cbind(AUCall0, AUCall)
}else{
## glnnet with positive coef
# if(noDIAG==1){
#   CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],exclude=gi,nfolds = nfold, foldid = foldid,
#                           keep = keep, lower.limits=0, upper.limits=Inf, grouped = FALSE)
# }else{
#   CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],nfolds = nfold, foldid = foldid,
#                           keep = keep, lower.limits=0, upper.limits=Inf, grouped = FALSE)
# }
## glmnet
if(noDIAG==1){
CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],exclude=gi,
nfolds = nfold, foldid = foldid, keep = keep, grouped = FALSE)
}else{
CV_results <- cv.glmnet(X_matrix,Y_vector,alpha=alphas[test],
nfolds = nfold, foldid = foldid, keep = keep, grouped = FALSE)
}
plot(CV_results)
lambda[test] <- CV_results$lambda.min
cvERROR[test] <- CV_results$cvm[CV_results$lambda==CV_results$lambda.min]
cverrorall <- cbind(cverrorall, cvERROR)
# coef.CV_results <- round(coef(CV_results, s='lambda.min'),3)
coef.CV_results <- coef(CV_results, s='lambda.min')
##
beta[coef.CV_results@i[-1],test] = coef.CV_results@x[-1]
theta[coef.CV_results@i+1,test] = coef.CV_results@x
theta[1,test] <- lambda*theta[1,test]
# theta[1,test] <- theta[1,test]/lambda
ptrain <- sgn(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test])
# ptrain <- sgn(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test])
# ptrain <- as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test]
ptrainall <- cbind(ptrainall, ptrain)
# View(cbind(as.matrix(X_matrix) %*% theta[-1,test] + theta[1,test],Y_vector))
aucplot <- plot.roc(Y_vector, as.numeric(ptrain), print.auc=T)
auc <- aucplot$auc
AUCall <- cbind(AUCall, auc)
minIdx <- max(which(cvERROR==min(cvERROR)))
lambda_res[gi] <- lambda[minIdx]
alpha_res[gi] <- alphas[minIdx]
# pred_lambda_min[,gi] <- beta[,minIdx]
pred_lambda_min[,gi] <- theta[,minIdx]
ptrainall0 <- cbind(ptrainall0, as.matrix(ptrainall[,minIdx]))
AUCall0 <- cbind(AUCall0, AUCall[,minIdx])
}
print(gi)
}
mean(AUCall0)
coefall <- pred_lambda_min
# namerow <- c("Intercept", "G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
# rownames(coefall) <- namerow
# namecol <- c("G1","G2","G3","G4","G5","G6","G7","G8", "G9", "G10")
# colnames(coefall) <- namecol
# sum(coefall[2:11,]!=0)
# write.csv(coefall, file="CoefAllSize10\\coefalldream3p1_matrix.csv")
## Dynamics Acc
DyAcc <- function(datahatA,ptrainall){
X <- datahatA[-1,]
kk <- 0
for (j in 1:dim(X)[2]) {
for (k in 1:(dim(X)[1])) {
if (as.numeric(ptrainall[k,j]) == as.numeric(X[k,j]))
kk <- kk + 1
}
}
acc <- kk/((dim(X)[2])*(dim(X)[1]))
return(acc)
}
DyAcc <- DyAcc(datahatA,ptrainall0)
DyAcc
# Performance Compare -----------------------------------------------------
## 0-无向
# SIGN = 0
SIGN = 1
## Gold standard GRN
getwd()
setwd("/home/lly/R/Boolean/Data/DREAM/DREAM3 in silico challenge/Size50/NetAdjMatrix")
# setwd("D:/E/博士/R_程序/Boolean/Data/DREAM/DREAM3 in silico challenge/Size50/NetAdjMatrix")
adj_gold <- as.matrix(read.csv(file = " InSilicoSize50-Ecoli1-adj .csv"))
# adj_gold <- as.matrix(read.csv(file = " InSilicoSize10-Yeast3-adj .csv"))
# no self-loof, direct
if(SIGN == 1){
adj_gold[row(adj_gold) == col(adj_gold)] <- 0
adj_matrix <- coefall[-1,]
}
# undirect
if(SIGN == 0){
adj_gold[which(adj_gold != 0)] <- 1
adj_matrix <- abs(coefall[-1,])
}
## Final ranked list, AUROC and AUPR
# adj_matrix <- adj_matrix/max(adj_matrix)
adjstand <- apply(abs(adj_matrix), 2, function(x){(x-min(x))/(max(x)-min(x))} )
adjstand[adjstand <= 1e-5] = 0
adj_matrix <- adjstand * sign(adj_matrix)
## 把NAN变成0
adj_matrix[is.na(adj_matrix)] <- 0
# adj_matrix[adj_matrix > 0] = 1
## load code
source('/home/lly/R/Boolean/R/SINCERITIES functions/PermanceFunction.R')
# source('D:/E/博士/R_程序/Boolean/R/SINCERITIES functions/PermanceFunction.R')
library(pracma)
AUCresult <- auc_from_ranks_TC_sign(adj_matrix, adj_gold, 1000)
AUROC <- AUCresult$AUROC
AUPR <- AUCresult$AUPR
AUC <- cbind(AUROC,AUPR)
AUC
AUCALL <- rbind(AUCALL, AUC)
DyAcc
mean(AUCall0)
performance <- performance_from_ranks_TC_sign(adj_matrix, adj_gold, 0)
performance
}
data = as.matrix(read.table(file = "InSilicoSize50-Ecoli1-nonoise-trajectories.tsv", header=T))
dim(data)[1]
dim(data)[1]/21
AUCALL <- c()
l <- 21
data = as.matrix(read.table(file = "InSilicoSize50-Ecoli1-nonoise-trajectories.tsv", header=T))
run <- dim(data)[1]/l
run
performance
